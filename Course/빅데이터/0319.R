setwd("c:/r_workdata")

Sys.setlocale("LC_ALL","Korean")

library(lubridate)

# 문제) 다음 식을 날짜 계산이 정상적으로 출력되게 바꾸시오
#'2022-02-14' -'21.11.06'

# 날짜를 Date 형식으로 변환
# 연도-월-일 형식은 날짜 형식이라 포멧을 사용하지 않아도 된다.
# 연도.월.일 형식은 날짜 형시이 아니라 포멧 사용하여 2자리 연도 표기
as.Date('2022-02-14')-as.Date('21.11.06', format="%y.%m.%d")

#R에서는 날짜를 사용할 때 POSIXlt 와 POSIXct 클래스를 사용
#POSIXlt는 날짜를 년, 월,일로 표시하는 리스트형 클래스
#POSIXct는 날짜를 연속적인 데이터로 인식하여 1970년을 기준으로 초 단위 계산산

as.Date("2025-03-19 15:51:00") - as.Date("2025-03-19 13:50:00")
as.POSIXct("2025-03-19 15:51:00") - as.POSIXct("2025-03-19 13:50:00")

# 6-2 lubridate 패키지 사용하여 날짜 게산
install.packages("lubridate") # 무슨 창 뜨면 아니오 누르기
library(lubridate)

d=now()

year(d)
month(d)
day(d)
wday(d)

wday(d, label=T)

d2=d-days(2)
d2

d+days(100)
d+years(1)

#문제) 현재 날짜와 시간에 1년 2개월 3일 4시간 5분 6초를 더해라

d+years(1)+months(2)+days(3)+hours(4)+minutes(5)+seconds(6)

d2= hm("22:30")
d2

d3 = hms("22:30:15")
d3

# seq() 순차적, 선형적으로 날짜 데이터를 생성
seq(as.Date("2025-01-01"), as.Date("2025-12-31"), 1)
seq(as.Date("2025-01-01"), as.Date("2025-12-31"), 'day')

seq(as.Date("2025-01-01"), as.Date("2025-12-31"), 'month')#주의: 30,31을 줄 경우 값이 달라짐
seq(as.Date("2025-01-01"), as.Date("2125-12-31"), 'year')

d=seq(as.Date("2025-01-01"), as.Date("2125-12-31"), 'year')
d #저장되어 있는 형태가 vector이기 때문에 index를 가진다. vector는 1차원 배열과 유사함

d[45]
d[35:45] #35번지 부터 45번지까지
d[c(35,45)]# R의 모든 데이터는 vector를 사용한다. vector에서 가장 많이 사용되는 함수를 combine()이다. c함수라고 부름


# 문제] 위에서 작성한 날짜 데이터의 35번째 데이터와 45번째 데이터의 다음 년도를 출력하시오

d[c(35,45)]+years(1)

#변수
#R은 명시적인 데이터 타입이 없다 대입할때 정해져 마지막에 저장되는 값만 인식
#항상 데이터 가공 후엔 새로운 변수에 저장하기
v1='aa'
v1
class(v1)

v1=now()
v1
class(v1)

v1=Sys.Date()
class(v1)

v1=c('a','b','c')
v1
v1[1]
v1[2]
class(v1)
str(v1)

v1 <- 2
v1

v2<-v3<-v4<-1
v3
v2

v2=v3=v4=2
v3
v2

10->v5->v6->v7 #일반적으로 왼쪽에 값이 올 수 없지만 R은 가능 근데 이건 별루 안권장
v6
v7

s1="very easy R"
s1

c1=c(1,2,3)
c1
class(c1)

c1=c(1,2,3,4,'5')
class(c1)
c1

#변수 설정 시 유의 사항
# 1. 대소문자 구분
# 2. 영어, 숫자 모두 사용 가능하지만 첫문자는 반드시 문자로 
# 3. 한글 사용 가능
# 4. 예약어 사용 못한다. (예약어: 프로그램 사용을 위해 미리 정해진 것들)
# is, else, ifelse, for, while, break, function, TRUE, FALSE, NA, NULL, in, rep...

n1=1
n2=2
n1+n2

s1=1:5 #숫자의 연속 저장은 가능하다.
s1

s2='a':'f' #문자열의 연속 저장은 불가능

n3='3'
n1+n3
n1+as.numeric(n3) #n3을 형변환 해야한다.

objects()
objects(all.names=T) #숨김 변수까지 다 보임
rm(s1) #삭제

objects()
rm(list=ls()) # 전체삭제
objects()

#데이터처리 객체
# - 동일데이터 타입
# 1. 스칼라(=변수) : 단일 데이터 처리 
# 2. 벡터 : 1차원 배열(스칼라를 여러개 합친 것)
# 3. matrix : 2차원 배열(벡터를 여러개 합친 것)
# 4. array : 3차원 배열(matrix를 여러개 합친 것)
# - 다른 데이터 타입
# 1. list : 벡터와 비슷(키,값) 형태
# 2. dataframe : 엑셀의 표나 db의 테이블과 같음(db의 컬럼처럼 라벨이 있음)

# 벡터: 1차원 배열
# 1. C() 함수로 작성
# 2. 인덱스는 1부터 시작
# 3. 하나의 자료형만 사용한다.
# 4. 결측값은 'NA' 사용
# 5. NULL은 어떤 형식도 취하지 않는 특별한 객체

c(1,2,3,4,5)
c(1,2,'3',4,5)

v1=c(1,2,3,4,5)
v1[1]
v1[0]# 벡터는 1부터 시작이야
v1[-3] #3번째 데이터를 빼고 가져와달라 (뒤에서 인덱싱 아님)
v1[3]

length(v1)

#문제) v1의 첫번쨰 인덱스에서 끝에서 세번째 인덱스 까지의 값을 출력하시오. 단, lengt()를 이용할 것
v1[1:length(v1)-3]
v1[1:3]
v1[1:(length(v1)-2)]
v1[-1:3] # 인덱스 앞 - 가 붙은것과 아닌것을 혼용할 수 없다.
v1[-1:-3] # 1부터 3까지의 데이터를 빼고 가져와라

v1[2:4]
v1[2]=6
v1

v1=c(v1,7)
v1

#na가 들어감
v1[9]=9
v1

#배열 중간에 값 붙이기
append(v1, 10, after=3) #v1에 10을 3번 인덱스 뒤에 붙여라
append(v1,c(10,11), after=3)
v1

v1=append(v1,c(10,11), after=3)
v1

v1=append(v1,12,after=0) #맨 앞에 삽입할떄 0번지를 쓰기 때문에 배열이 1번지부터 시작하는 것임
v1

#벡터 연산
c(1,2,3)+c(4,5,6) # 같은 인덱스 끼리 연산
c(1,2,3)+1 # 모든 인덱스에 연산

v1=c(1,2,3)
v2=c(3,4,5)
v1+v2

v3=c(3,4,'5')
v1+v3 #문자열은 계산 할 수 없어

union(v1,v3) # 합쳐주고 싶을 때 같은 값은 1개만 출력

v1=c(1,2,3)
v4=c(1,2,3,4)
v1+v4 #두 벡터의 길이가 다를 경우 순환원리가 적용

v1-v2

v1=c(1,2,3)
v2=c(3,4,5)

setdiff(v1,v2) #차집합: v1에는 있지만 v2에는 없는 요소 출력
intersect(v1,v2) #교집합: v1과 v2에 공통적인 요소 출력

#벡터에 각 컬럼에 이름을 지정
f=c(10,20,30)
f

names(f) =c('apple','banana','peach')
f

# 벡터에 연속적인 데이터 할당 : seq(), rep() 레플리카

v4= c(1:5)
v4

v5=seq(1:5) #잘못된 사용법 , 사이의 갯수를 세어주는거임임
v5

v5=seq(10:15)
v5

v5=seq(1,5) # :대신 , 사용해야함
v5

v6=seq(-2.2)
v6

c6=c(-2:2)
c6

v7=seq(1,10,2) #1부터 10까지 2씩 증가하는 값 생성
v7

v8=rep(1:3,2)
v8

v9=rep(1:3, each=2)
v9

#벡터의 길이
v1
length(v1)
NROW(v1)

#벡터의 특정 문자 포함 여부
v7
3%in%v7
4%in%v7































